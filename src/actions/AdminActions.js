// Basic actions that can be generated by the views
var Promise = require('promise');
var labels = require('./index');
var constants = require('../utils/constants');
var maxSplit = require('../utils/maxSplit');

var BlogActions = require('./BlogActions');
var SectionsStore = require('../stores/SectionsStore');
var PageStore = require('../stores/PageStore');

// Debug
var debug = require('debug')('blog:server');

var AdminActions = {
	/**
	 * This is simply an Admin pass through to BlogActions#fetchBlogPost
	 *
	 * @param context The actionContext from Fluxible
	 * @param payload An object that contains the URL that data needs to be
	 		fetched for. payload.url must be a valid URL
	 * @return A Promise that reolves to true if everything succeeded.
	 */
	fetchBlogPost: function(context, payload) {
		return BlogActions.fetchBlogPost(context, payload);
	},

	/**
	 * This is simply an Admin pass through to BlogActions#updateSections
	 *
	 * @param context The actionContext from Fluxible
	 * @param payload This is empty
	 * @return A Promise that resolves to true if the action succeeded
	 */
	fetchSections: function(context, payload) {
		return BlogActions.updateSections(context, payload);
	},

	/**
	 * This action simply loads the desired CSRF token into the store
	 *
	 * @param context The actionContext from Fluxible
	 * @param payload The generated CSRF token
	 * @return A Promise that resolves to true if the action succeeded
	 */
	loadCSRF: function(context, payload) {
		return new Promise(function(resolve, reject) {
			context.dispatch(labels.LOAD_CSRF, payload);
			resolve(true);
		});
	},

	/**
	 * This action figures out the user's desires from the URL that's being
	 * pushed on to window, and then delegates the actual update of the UI to
	 * the various other actions in this object. Essentially, this is the router
	 * for the admin section
	 *
	 * @param context The actionContext from Fluxible
	 * @param payload An object containing the URL that is being redirected to
	 * @return A Promise that resolves to true if the action succeeded
	 */
	moveToNewPage: function(context, payload) {
		var promise; 								// Variable to be returned
		var actions = require('./AdminActions');	// `this` has been bound!

		// First get the check for the logout out of the way
		if (payload.url === constants.LOGOUT_URL) {
			return actions.logout(context, {});
		}

		// Then figure out the sections, etc from the URL
		var urlParts = payload.url.split('/');
		var sectionsStore = context.getStore(SectionsStore);
		var pageStore = context.getStore(PageStore);

		// Now call the appropriate actions based on the identified parts
		if (payload.url.indexOf(constants.ADMIN_SECTIONS_URL) === 0
				&& urlParts.length === 3) {				// Visit the home page
			promise = actions.editStructure(context, {});
		} else if (payload.url.indexOf(constants.ADMIN_SECTIONS_URL) === 0
					&& urlParts.length >= 4) {			// Edit a section
			var section = sectionsStore.getSection('/' + urlParts[3]);
			if (!section) {
				promise = new Promise(function(resolve, reject) { reject("Unknown Section!"); });
			} else {
				promise = actions.editSection(context, section);
			}
		} else if (payload.url.indexOf(constants.ADMIN_PAGES_URL) === 0
					&& urlParts.length >= 4) {			// Edit a page
			// First fetch the section. Special logic for the root section
			var section = sectionsStore.getSection('/' + urlParts[3]);
			if (!section) {
				var section = sectionsStore.getSection('/');
			}

			// Then get the section. Keep in mind that the /create route needs a
			// stub slide object
			var pageUrl = '/' + urlParts.slice(3).join('/');
			var slide;
			if (new RegExp("^(\\/[\\w-]*)?\\" + constants.CREATE_PAGE_URL + "$").test(pageUrl)) {
				slide = { title: "New Page", url: "", html: "" };
			} else {
				slide = pageStore.getPost(pageUrl);
			}

			// Finally, transition to the desired editor only if this was a
			// matching route
			if (!slide) {
				promise = new Promise(function(resolve, reject) { reject("Unknown Page!"); });
			} else {
				promise = actions.editPage(context, { section: section, slide: slide });
			}
		} else {										// Unknown page
			promise = new Promise(function(resolve, reject) { reject("Unknown URL!"); });
		}

		// Return the promise
		return promise;
	},

	/**
	 * A user uses this action to edit the all the sections (structure)
	 *
	 * @param context The actionContext from Fluxible
	 * @param payload This is empty
	 * @return A Promise that resolves to true if the action succeeded
	 */
	editStructure: function(context, payload) {
		return new Promise(function(resolve, reject) {
			context.dispatch(labels.EDIT_STRUCTURE, {});
			resolve(true);
		});
	},

	/**
	 * A user uses this action to edit the pages within a section
	 *
	 * @param context The actionContext from Fluxible
	 * @param payload The section that the user wants to edit
	 * @return A Promise that resolves to true if the action succeeded
	 */
	editSection: function(context, payload) {
		return new Promise(function(resolve, reject) {
			context.dispatch(labels.EDIT_SECTION, payload);
			resolve(true);
		});
	},

	/**
	 * A user uses this action to edit a particular page
	 *
	 * @param context The actionContext from Fluxible
	 * @param payload The page (& linked section) that the user wants to edit
	 * @return A Promise that resolves to true if the action succeeded
	 */
	editPage: function(context, payload) {
		return new Promise(function(resolve, reject) {
			context.dispatch(labels.EDIT_PAGE, payload);
			resolve(true);
		});
	},

	/**
	 * This function logs the user into the app if the hash provided via the
	 * payload is acceptable. If not, it sends an error. NOTE: This action is
	 * only ever executed on the client. There is no check to ensure this yet
	 *
	 * @param context The actionContext from Fluxible
	 * @param payload The details about login. Contains a single field: hash
	 * @return A Promise that resolves to true if the action succeeded
	 */
	login: function(context, payload) {
		return new Promise(function(resolve, reject) {
			var idToken = window.localStorage.getItem(constants.LOCAL_STORAGE_USER_TOKEN);
			var authHash = payload.hash;

			// Taken directly from Auth0
			if (!idToken && !!authHash) {
				if (authHash.id_token) {
					idToken = authHash.id_token;
					window.localStorage.setItem(constants.LOCAL_STORAGE_USER_TOKEN, idToken);
				}
				if (authHash.error) {
					reject(authHash.error);
				}
			}

			// Ensure that the app knows that we are logged in
			context.dispatch(labels.LOGGED_IN, { idToken: idToken });
			resolve(true);
		});
	},

	/**
	 * This function logs the user out of the app. NOTE: This action should
	 * only ever be executed on the client. There is no check to ensure this yet
	 *
	 * @param context The actionContext from Fluxible
	 * @param payload The details about logout. No payload
	 * @return A Promise that resolves to true if the action succeeded
	 */
	logout: function(context, payload) {
		return new Promise(function(resolve, reject) {
			window.localStorage.removeItem(constants.LOCAL_STORAGE_USER_TOKEN);
			context.dispatch(labels.LOGGED_OUT, {});
			resolve(true);
		});
	}
}

module.exports = AdminActions;
